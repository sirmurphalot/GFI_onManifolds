stan_model_3 = sampling(fitted_model,data=ds)
k = 4
x_mat = matrix(c(my_predict, my_predict**2, my_predict**3, my_predict**4), nrow = length(x), ncol = k)
sig_mat = solve(t(x_mat) %*% x_mat)
mc = "
data {
int<lower=0> N;   // number of data items
int<lower=0> K;   // number of predictors
matrix[N, K] x;   // predictor matrix
vector[N] y;      // outcome vector
matrix[K,K] inverse_inner; // Inverse of inner product of the data matrix
int<lower=0> g; // g_K hyperparameter
}
parameters {
real alpha;           // intercept
vector[K] beta;       // coefficients for predictors
real<lower=0> sigma;  // error scale
}
transformed parameters {
vector[K] mu;
for (j in 1:K) mu[j] = 0;
}
model {
beta ~ multi_normal(mu, g * pow(sigma, 2) * inverse_inner);
y ~ normal(x * beta + alpha, sigma);  // likelihood
target+= -log(sigma);
}"
fitted_model = stan_model(model_code = mc)
ds <- list(N = length(x), K = k, y = my_response, x = x_mat, inverse_inner = sig_mat, g = max(length(x), k^2))
stan_model_4 = sampling(fitted_model,data=ds)
k = 5
x_mat = matrix(c(my_predict, my_predict**2, my_predict**3, my_predict**4, my_predict**5), nrow = length(x), ncol = k)
sig_mat = solve(t(x_mat) %*% x_mat)
mc = "
data {
int<lower=0> N;   // number of data items
int<lower=0> K;   // number of predictors
matrix[N, K] x;   // predictor matrix
vector[N] y;      // outcome vector
matrix[K,K] inverse_inner; // Inverse of inner product of the data matrix
int<lower=0> g; // g_K hyperparameter
}
parameters {
real alpha;           // intercept
vector[K] beta;       // coefficients for predictors
real<lower=0> sigma;  // error scale
}
transformed parameters {
vector[K] mu;
for (j in 1:K) mu[j] = 0;
}
model {
beta ~ multi_normal(mu, g * pow(sigma, 2) * inverse_inner);
y ~ normal(x * beta + alpha, sigma);  // likelihood
target+= -log(sigma);
}"
fitted_model = stan_model(model_code = mc)
ds <- list(N = length(x), K = k, y = my_response, x = x_mat, inverse_inner = sig_mat, g = max(length(x), k^2))
stan_model_5 = sampling(fitted_model,data=ds)
stan_model_3
stan_model_4
stan_model_2
stan_model$sigma
stan_model$sigma
summary(stan_model)$sigma
sigma(stan_model)
extract(stan_model)
extract(stan_model)$sigma
mean(extract(stan_model)$sigma)
stan_model_1 = stan_model
marginals = c(bridge_sampler(stan_model_1),
bridge_sampler(stan_model_1))
?bridge_sampler
marginals = c(bridge_sampler(stan_model_1)$logml,
bridge_sampler(stan_model_2)$logml,
bridge_sampler(stan_model_3)$logml,
bridge_sampler(stan_model_4)$logml,
bridge_sampler(stan_model_5)$logml)
marginals = exp(marginals)
priors = c(mean(extract(stan_model_1)$sigma),
mean(extract(stan_model_2)$sigma),
mean(extract(stan_model_3)$sigma),
mean(extract(stan_model_4)$sigma),
mean(extract(stan_model_5)$sigma))
posterior_model_probabilities = marginals*priors / (sum(marginals*priors))
posterior_model_probabilities
marginals
marginals = c(bridge_sampler(stan_model_1)$logml,
bridge_sampler(stan_model_2)$logml,
bridge_sampler(stan_model_3)$logml,
bridge_sampler(stan_model_4)$logml,
bridge_sampler(stan_model_5)$logml)
marginals
marginals + log(priors)
sum(exp(marginals + log(priors)))
signif(exp(marginals + log(priors)), digits = 20)
signif(exp(marginals + log(priors)), digits = 100)
install.packages("Rmpfr")
unnormalized_posterior_model_probabilities = marginals + priors
unnormalized_posterior_model_probabilities = marginals + log(priors)
unnormalized_posterior_model_probabilities
which.max(unnormalized_posterior_model_probabilities)
stan_model_3
draws = extract(stan_model_3)
y_post_pred = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27
length(y_post_pred)
density(y_post_pred)
plot(density(y_post_pred))
mean(y)
mean(x)
library(ggplot2)
draws = extract(stan_model_3)
y_post_pred = data.frame( x = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27)
ggplot(y_post_pred, aes(x = x)) + geom_density()
ggplot(y_post_pred, aes(x = x)) + geom_density()
library(ggplot2)
draws = extract(stan_model_3)
y_post_pred = data.frame( y = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27)
ggplot(y_post_pred, aes(x = y)) + geom_density(fill = "green")
library(ggplot2)
draws = extract(stan_model_3)
y_post_pred = data.frame( y = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27)
ggplot(y_post_pred, aes(x = y)) + geom_density(fill = "darkgreen")
library(ggplot2)
draws = extract(stan_model_3)
y_post_pred = data.frame( y = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27)
ggplot(y_post_pred, aes(x = y)) + geom_density(fill = "darkgreen", alpha = 0.7)
library(ggplot2)
draws = extract(stan_model_3)
y_post_pred = data.frame( y = draws$alpha + draws$beta[1] * 3 + draws$beta[2] * 9 + draws$beta[3] * 27)
ggplot(y_post_pred, aes(x = y)) + geom_density(fill = "darkgreen", alpha = 0.7) + ggtitle("Posterior Predictive Distribution for x = 3")
?sample
summary(stan_model_2)
stan_model_1$summary
extract(stan_model_1)$summary
extract(stan_model_1)
summary(stan_model_1)
summary(stan_model_1)$summary
#load the data
data(mtcars)
#create design matrix
X = data.frame(disp = mtcars$disp, hp = mtcars$hp, wt = mtcars$wt, drat = mtcars$drat)
#create response
Y = mtcars$mpg
#conduct a cross validation study to fit minimum MSE model
lasso.fit.1 = glmnet(as.matrix(X),Y,lambda = 1)
install.packages("glmnet")
library(glmnet)
?Lasso
install.packages("HDCI")
library(HCDI)
library(HDCI)
?Lasso
library(HDCI)
library(glmnet)
Sys.setenv('R_MAX_VSIZE'=32000000000)
q()
setwd("~/Documents/Research/GGM_EAS/CHMC_onSphere/STAN_Parameterized")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 2
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
int<lower=1> n;
int<lower=1> d;
vector[3] = y[n];
matrix[d,d] = sigma;
vector[n] dataX;
vector[n] dataY;
vector[n] dataZ;
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
# init_stan=list(list(phi=Yhatav,theta=))
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, #init = init_stan,
iter = Iters, cores = 4L)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 2
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
# init_stan=list(list(phi=Yhatav,theta=))
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, #init = init_stan,
iter = Iters, cores = 4L)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
# init_stan=list(list(phi=Yhatav,theta=))
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, #init = init_stan,
iter = Iters, cores = 4L)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, #init = init_stan,
iter = Iters, cores = 4L)
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, init = init_stan,
iter = Iters, cores = 4L)
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',algorithm = "HMC",data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
plot(FIDfit,pars="phi",show_density = TRUE)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 5000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L, chains=1)
# FIDfit=sampling(fiducial_stan, data = data_stan, #init = init_stan,
#                 iter = Iters, cores = 4L)
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 500000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=0
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L)
# FIDfit=sampling(fiducial_stan, data = data_stan, #init = init_stan,
#                 iter = Iters, cores = 4L)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 500000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=1
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_stan=list(list(phi=phi_start,theta=theta_start))
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_stan,
iter = Iters, cores = 4L)
# FIDfit=sampling(fiducial_stan, data = data_stan, #init = init_stan,
#                 iter = Iters, cores = 4L)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 500000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=1
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_fun <- function(...) list(theta = 0.7854, phi = 0.7854)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_fun,
iter = Iters, cores = 4L)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 50000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=1
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
DataX = rnorm(n,mean=m1,sd=sd1)
DataY = rnorm(n,mean=m2,sd=sd2)
DataZ = rnorm(n,mean=m3,sd=sd3)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_fun <- function(...) list(theta = 0.7854, phi = 0.7854)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_fun,
iter = Iters, cores = 4L)
# FIDfit=sampling(fiducial_stan, data = data_stan, #init = init_stan,
#                 iter = Iters, cores = 4L)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
setwd("~/Documents/Research/GGM_EAS/CHMC_onSphere/STAN_Parameterized")
library(rstan)
library(mvtnorm)
set.seed(13)
Iters = 50000
n = 4
d = 3
m1 = -sqrt(5/8)
m2 = 1/sqrt(8)
z_shift=1
m3 = 1/sqrt(16)+z_shift
sd1 = 1
sd2 = 1
sd3 = 1
# For the purposes of our experiment, our data must be the same as what we have on Matlab.
DataX = c(0.1713,-2.0252,0.8154,0.0977)
DataY = c(2.2951,0.1641,0.7312,1.5356)
DataZ = c(1.6317,1.8123,-0.4593,0.2301)
sigma=diag(3)
y=matrix(c(DataX,DataY,DataZ),ncol=3)
theta_start = 0.7854
phi_start = 0.7854
data_stan=list(d=d,n=n,y=y,sig=sigma,dataX=DataX,dataY=DataY,dataZ=DataZ)
init_fun <- function(...) list(theta = 0.7854, phi = 0.7854)
fiducial_stan = stan(file='MVN_sphere.stan',data = data_stan, init = init_fun,
iter = Iters, cores = 4L)
# FIDfit=sampling(fiducial_stan, data = data_stan, #init = init_stan,
#                 iter = Iters, cores = 4L)
FIDfit=fiducial_stan
plot(FIDfit,pars="phi",show_density = TRUE)
plot(FIDfit,pars="theta",show_density = TRUE)
FIDdraws <- extract(FIDfit)#,permute=FALSE, inc_warmup=TRUE)
temp_data=data.frame(Phi=FIDdraws$phi,Theta=FIDdraws$theta)
write.csv(temp_data,file="../sphereDraws.csv")
